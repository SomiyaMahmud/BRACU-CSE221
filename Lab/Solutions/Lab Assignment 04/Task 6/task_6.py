# -*- coding: utf-8 -*-
"""Task_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYH5GWe3r9r5IWAHT7_BgQ95RwSH_MX4
"""

inp = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/input 6.txt", "r")
out = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/output 6.txt", "w")
R, H = inp.readline().split()
R, H = int(R), int(H)
G = [['#' for i in range(H + 2)] for j in range(R + 2)]

for i in range(1,R+1):
    temp = inp.readline().strip()
    for j in range(1,H+1):
        G[i][j] = (temp[j-1])

visited = [[0 for i in range(H+2)] for j in range(R+2)]
for a in range(R+2):
    for b in range(H+2):
        if G[a][b] == '#':
            visited[a][b] = -1
        else:
            visited[a][b] = 0

def diamond_count(i,j):
    temp_count = 0
    if G[i][j] == 'D':
        temp_count += 1
    visited[i][j] = 1
    moves = [[i-1, j], [i+1, j], [i, j +1], [i, j-1]]
    for x in moves:
        if visited[x[0]][x[1]] == 0:
            temp_count += diamond_count(x[0], x[1])
    return temp_count


count=0
for i in range(R+2):
    for j in range(H+2):
        if G[i][j] == '.' and visited[i][j] == 0:
            temp_count = diamond_count(i, j)
            count = max(count,temp_count)

out.write(f'{count}')
inp.close()
out.close()


"""
First store the inputs in an adjacent matrix with a border created by ‘#’ to avoid index out of range error
while traversing. Again take a 2D array named ‘visited’ to track the visited and unvisited cells. Then we check the
top, bottom, left, and right of the current cell using DFS algorithm and if we find any ‘D’ then update the count
variable. But there could be more unvisited cells and to visit them we need to call the function again and again
until all the valid cells are not visited and update the count variable. Lastly, print the count.
"""