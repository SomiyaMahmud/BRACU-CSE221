# -*- coding: utf-8 -*-
"""Task_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYH5GWe3r9r5IWAHT7_BgQ95RwSH_MX4
"""

inp = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/input 4.txt","r")
out = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/output 4.txt","w")
M, N = inp.readline().split()
M, N = int(M), int(N)
G = [[] for i in range(M+1)]

for i in range(N):
    u, v = inp.readline().split()
    u, v = int(u), int(v)
    G[u].append(v)

red = [0 for i in range(M+1)]
blue = [0 for i in range(M+1)]
cycle = False

def DFS_Cycle(G, s):
    global cycle
    red[s] = 1
    blue[s] = 1
    for u in G[s]:
        if red[u] != 0:
            if blue[u] == 1:
                cycle = True
        else:
            DFS_Cycle(G,u)
    blue[s] = 0

DFS_Cycle(G,1)
if cycle == True:
    out.write(f"Yes")
else:
    out.write(f"No")

inp.close()
out.close()

"""
I use DFS to solve this problem. There are 2 arrays, blue and red. Whenever I explore an
unvisited neighbor, I mark it as visited by updating the value of blue and red to 1. When a vertex
has no unvisited neighbors, before backtracking to the previous vertex update the value of that vertex in blue array to 0
and explore other unvisited neighbors. To find the cycle, we check if the red and blue of that next
adjacent vertex are 1 or not. If both are 1 then a cycle exists.
"""