# -*- coding: utf-8 -*-
"""Task_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYH5GWe3r9r5IWAHT7_BgQ95RwSH_MX4
"""

import queue
q = queue.Queue()

inp = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/input 2.txt", "r")
out = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/output 2.txt", "w")
N, M = inp.readline().split()
N, M = int(N), int(M)
G = [[] for i in range(N+1)]

for i in range(N):
    u, v = inp.readline().split()
    u, v = int(u), int(v)
    G[u].append(v)
    G[v].append(u)


def BFS(G,s):
    col=[0 for i in range(N + 1)]
    q.put(s)

    col[s] = 1

    while not q.empty():
        p = q.get()
        out.write(f"{p} ")
        for x in G[p]:
            if col[x] == 0:
                col[x] = 1
                q.put(x)

BFS(G,1)
inp.close()
out.close()

"""
To implement BFS, first declare an array named 'col' with initial values set to zero to track visited vertices.
Start checking the graph from the source vertex and enqueue it into a queue. Whenever visiting a non-visited
adjacent vertex, update the value of the color array to 1 for that vertex, and enqueue it in queue
and the outputs are the traversal order of the  vertices.
"""