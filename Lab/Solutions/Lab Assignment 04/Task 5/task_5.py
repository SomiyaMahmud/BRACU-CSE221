# -*- coding: utf-8 -*-
"""Task_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYH5GWe3r9r5IWAHT7_BgQ95RwSH_MX4
"""

import queue
q = queue.Queue()

inp = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/input 5.txt","r")
out = open("/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 04/output 5.txt","w")
M, N, D = inp.readline().split()
M, N, D = int(M), int(N), int(D)
G = [[] for i in range(M+1)]

for i in range(N):
    u, v = inp.readline().split()
    u,v = int(u), int(v)
    G[u].append(v)
    G[v].append(u)

col = ['White' for i in range(M+1)]
par = [0 for i in range(M+1)]
dis = [0 for i in range(M+1)]

def bfs(G,s):
    col[s] = 'Grey'
    q.put(s)
    while not q.empty():
        u = q.get()
        for x in G[u]:
            if col[x] == 'White' :
                col[x ]= 'Grey'
                dis[x] = dis[u] + 1
                par[x] = u
                q.put(x)
        col[u] = 'Black'

path=[]
def shortest_path(G, des):
    path.append(des)
    cur = des
    while par[cur] != 0:
        path.append(par[cur])
        cur = par[cur]

bfs(G,1)
shortest_path(G, D)

out.write(f'Time: {dis[D]} \n')
out.write(f'Shortest Path: ')
while path:
    out.write(f'{path.pop()} ')

inp.close()
out.close()

"""
Firstly, we use the BFS Algorithm to get the distance and parents of all the vertex.
Then traces back from the destination vertex to the source vertex by following parent array and store them in a stack.
Lastly, pop the values from the stack which give the shortage path.
"""