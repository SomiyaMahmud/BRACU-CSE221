# -*- coding: utf-8 -*-
"""Task_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYH5GWe3r9r5IWAHT7_BgQ95RwSH_MX4
"""

import heapq
inp = open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 06/input 3.txt','r')
out = open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 06/output 3.txt','w')
N, M = inp.readline().split()
N, M = int(N), int(M)
G = [[] for i in range(N+1)]

for i in range(M):
    u,v,w = inp.readline().split()
    u,v,w = int(u),int(v),int(w)
    G[u].append((v, w))

col = ['White'] * (N+1)
dis = [float('inf')] * (N+1)

def Dijkstra(G,s):
    dis[s]=0
    priority_q=[]
    heapq.heappush(priority_q, (0, s))

    while priority_q:
        dist, cur_node = heapq.heappop(priority_q)
        for u, weight in G[cur_node]:
           if col[u] == 'White':
                if max(dis[cur_node], weight) < dis[u]:
                    dis[u] = max(dis[cur_node], weight)
                    heapq.heappush(priority_q,(dis[u],u))
        col[cur_node]='Black'

Dijkstra(G,1)

if dis[N] < float('inf'):
    out.write(f"{dis[N]}")
else:
    out.write(f"IMPOSSIBLE")
inp.close()
out.close()

'''
The solution same as Task-1 with a little change. Instead of comparing with the sum, here we
compare the previous distance with the maximum value between the distance of the current vertex
and the weight of the adjacent vertex. If there is no path from vertex 1 to N, then print Impossible,
otherwise print the n-th index value of the distance array
'''