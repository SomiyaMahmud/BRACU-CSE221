# -*- coding: utf-8 -*-
"""Task_1a.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYH5GWe3r9r5IWAHT7_BgQ95RwSH_MX4
"""

inp = open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 05/input 1a.txt','r')
out = open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 05/output 1a.txt','w')
N, M = inp.readline().split()
N,M = int(N),int(M)
G = [[] for i in range(N+1)]

for a in range(M):
    u,v=inp.readline().split()
    u, v = int(u), int(v)
    G[u].append(v)

col = ['White']*(N+1)
start = [0]*(N+1)
finish = [0]*(N+1)
cycle = False
stack = []

col = ['White']*(N+1)
start = [0]*(N+1)
finish = [0]*(N+1)

cycle = False
stack = []

def cycle_check(G,s):
    global cycle
    time = 0

    col[s] = 'Grey'
    time += 1
    start[s] = time
    for u in G[s]:
        if col[u] == 'White':
            cycle_check(G,u)
        elif col[u] == 'Grey':
            cycle = True

    col[s] = 'Black'
    time += 1
    finish[s] = time
    stack.append(s)

def TopologicalSort(G):
    for v in range(1,N+1):
        if col[v] == 'White':
            cycle_check(G,v)
            if cycle == True:
                out.write('IMPOSSIBLE')
                break
    else:
        while len(stack) != 0:
            out.write(f'{stack.pop()} ')

TopologicalSort(G)
inp.close()
out.close()

'''
Firstly, we check if there is any cycle exists or not. If any cycle exists then print ‘Impossible’.
Otherwise, traverse the whole graph using DFS and store the vertices in a stack according to their ascending finising time.
Later, when all the nodes are traversed, pop back the vertices from the stack one by one and it will gives the topological sorting output.
'''