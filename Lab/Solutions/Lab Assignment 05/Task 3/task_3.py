# -*- coding: utf-8 -*-
"""Task_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYH5GWe3r9r5IWAHT7_BgQ95RwSH_MX4
"""

inp = open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 05/input 3.txt', 'r')
out = open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 05/output 3.txt', 'w')
N, M = inp.readline().split()
N, M = int(N), int(M)
G = [[] for i in range(N+1)]
rev_G = [[] for i in range(N+1)]

for i in range(M):
    u, v = inp.readline().split()
    u, v = int(u), int(v)
    G[u].append(v)
    rev_G[v].append(u)

col = ['White'] * (N+1)
start = [0] * (N+1)
finish = [0] * (N+1)

stack=[]
path = []
store=[]

def DFS_visit(G):
    for i in range(1, N+1):
        if col[i] == 'White':
            DFS(G, i)

def DFS(G, s):
    time=0
    col[s] = 'Grey'
    time += 1
    start[s] = time
    for u in G[s]:
        if col[u] == 'White':
            DFS(G, u)
    col[s] = 'Black'
    time += 1
    finish[s] = time
    stack.append(s)

DFS_visit(G)

col = ['White'] * (N+1)

def newDFS(rev_G, u):
    col[u] = 'Grey'
    path.append(u)
    for v in rev_G[u]:
        if col[v] == 'White':
            newDFS(rev_G, v)
    col[u] = 'Black'

while len(stack) != 0:
    u = stack.pop()
    if col[u] == 'White':
        newDFS(rev_G, u)
        path.sort()
        store.append(path)
        store.sort()
        path = []


for i in store:
    out.write(f'{i} \n')
inp.close()
out.close()

'''
Traverse the whole graph using DFS and record the finishing time for each vertex.
Then transpose the graph and traverse it using DFS, but in the order of decreasing finishing time of the vertices.
While traversing , each time when we complete a DFS, a strongly connected component is found.
'''