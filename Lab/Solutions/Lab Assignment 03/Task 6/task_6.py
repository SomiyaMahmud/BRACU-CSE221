# -*- coding: utf-8 -*-
"""task_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iyLSigYJr8M-0EXL7AOUxUvg5O71ofjz
"""

inp=open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 03/input 6.txt','r')
out=open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 03/output 6.txt','w')

def Partition(arr,l,h):
    pivot=arr[h]
    i=l-1
    for j in range(l,h):
        if arr[j]<pivot:
            i+=1
            arr[i],arr[j]=arr[j],arr[i]
    arr[i+1], arr[h] = arr[h], arr[i+1]
    return i+1

def smallest(arr,l,h,k):
    if l==h:
        return arr[l]
    else:
        p=Partition(arr,l,h)
        if p==k:
              return arr[p]
        elif p<k:
              return smallest(arr,p+1,h,k)
        else:
              return smallest(arr,l,p-1,k)
N = int(inp.readline())
arr = [int(i) for i in inp.readline().split()]
Q = int(inp.readline())
for a in range(Q):
    x = int(inp.readline())
    y = smallest(arr,0,N-1,x)
    out.write(f"{y-1}\n")

inp.close()
out.close()

"""
For this task, we use the partition algorithm from quick sort which already describe in task 5.
After applying the partition algorithm, it will return the correct position of the pivot value. It will
make the array as the left elements of the pivot are smaller than the pivot and the right elements
are greater than the pivot. Next, we check the value of k is less than or greater than the value
returned by the partition algorithm. If less than the returned value then apply the algorithm to the
left part of the array otherwise it applies to the right part of the array and if the value returned by
the partition and k are the same, then terminate the algorithm and return the k-th smallest value.
"""