# -*- coding: utf-8 -*-
"""task_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iyLSigYJr8M-0EXL7AOUxUvg5O71ofjz
"""

inp=open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 03/input 5.txt','r')
out=open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 03/output 5.txt','w')
N=int(inp.readline())
arr = [int(i) for i in inp.readline().split()]

def quickSort(arr,l,h):
    if l<h:
        p=partition(arr,l,h)
        quickSort(arr,l,p-1)
        quickSort(arr,p+1,h)
    return arr

def partition(arr,l,h):
    pivot=arr[h]
    i=l-1
    for j in range(l,h):
        if arr[j]<pivot:
            i+=1
            arr[i],arr[j]=arr[j],arr[i]
    arr[i+1], arr[h] = arr[h], arr[i+1]
    return i+1

Q = quickSort(arr,0,N-1)
for val in range(len(Q)):
    out.write(f"{Q[val]} ")
inp.close()
out.close()

"""
In the partition function we fixed the righttmost value as a pivot. There are two pointers i and j. i start from the
-1 index and j starts from the 1st index. Through iteration, check whether the value of j is less than the pivot. If yes, then
increase i by 1 and then swap the value of i and j with each other. After finishing every iteration
swap the value of i and pivot with each other. After applying the partition algorithm, it will
return the correct position of the pivot value and produce a division into two subarrays where in
the left subarray all values are less than pivot and in the right subarray all values are greater than
the pivot. This is how quicksort recursively sorted the subarrays and then again merge them.
"""