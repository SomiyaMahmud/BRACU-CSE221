# -*- coding: utf-8 -*-
"""task_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iyLSigYJr8M-0EXL7AOUxUvg5O71ofjz
"""

inp=open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 02/input 3.txt','r')
out=open('/content/drive/MyDrive/CSE221 Lab(Sp-24)/Lab 02/output 3.txt','w')
n=int(inp.readline())
G = []

for a in range(n):
    s,e=inp.readline().strip().split(' ')
    s,e=int(s),int(e)
    G.append((s, e))

G.sort(key=lambda x:x[1])

task = []
count = 0
start = -1

for i in range(len(G)):
    if G[i][0] >= start:
        count+=1
        task.append(G[i])
        start=G[i][1]

out.write(f'{count}\n')
for x in range(len(task)):
    out.write(f'{task[x][0]} {task[x][1]} \n')

inp.close()
out.close()

"""
Firstly, take a list of tuples and each tuple stores the starting and finishing time. Sort the list
based on the finishing time of the tuples. Then take another empty list and append the first
element of the main list and from the second element check if the finishing time of the current
tuple is smaller than the starting time of the next tuple. If yes, then append it to the 2nd list. The
value of the 2nd list will be the output of this problem.
"""